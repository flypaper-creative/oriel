import React, { useMemo, useRef, useState } from "react";
import { useOrielStore } from "../../state/store";
import { clamp } from "../../utils/format";

type DragKind = "none"|"pan"|"reso"|"move"|"resize-l"|"resize-r";
type DragState =
  | { kind:"none" }
  | { kind:"pan"; x0:number; start:number; end:number }
  | { kind:"reso"; x0:number; t:number }
  | { kind:"move"; id:string; x0:number; t0:number; t1:number; committed:boolean }
  | { kind:"resize-l"; id:string; x0:number; t0:number; t1:number; committed:boolean }
  | { kind:"resize-r"; id:string; x0:number; t0:number; t1:number; committed:boolean };

export function Timeline(){
  const ref = useRef<HTMLDivElement|null>(null);
  const { shards, setShards, reso, setReso, viewStart, viewEnd, setView, setSelected, pushLog } = useOrielStore();

  const domain = Math.max(1000, viewEnd - viewStart); // min span 1s to avoid div-by-0
  const widthPx = ()=> Math.max(1, ref.current?.clientWidth || 1);
  const toX = (ms:number)=> ((ms - viewStart) / domain) * widthPx();           // ms -> px
  const fromX = (x:number)=> viewStart + (x / widthPx()) * domain;             // px -> ms

  // ticks
  const ticks = useMemo(()=>{
    // choose step based on span for readable labels
    const span = domain;
    const steps = 8;
    const gran = [1000, 2000, 5000, 10000, 30000, 60000, 5*60000, 10*60000, 30*60000, 60*60000];
    let step = gran[0];
    for (const g of gran) if (span/steps > g) step = g;
    const first = Math.floor(viewStart/step)*step;
    const arr:number[]=[];
    for (let t=first; t<=viewEnd; t+=step) arr.push(t);
    return { arr, step };
  }, [viewStart, viewEnd]);

  // drag management
  const [drag, setDrag] = useState<DragState>({kind:"none"});

  // Pointers for pinch
  const pts = useRef(new Map<number, {x:number,y:number}>());
  const pinch = useRef<null | {d0:number; centerT:number; startSpan:number}>(null);

  // Helpers to start drag on shard with threshold
  const DRAG_THRESH = 4; // px before we commit to drag (prevents "hard to click")
  function makeShardStart(kind: "move"|"resize-l"|"resize-r", s:any){
    return (e:React.PointerEvent)=>{
      if(!ref.current) return;
      ref.current.setPointerCapture(e.pointerId);
      setDrag({ kind, id:s.id, x0:e.clientX, t0:s.t0, t1:s.t1, committed:false });
      e.stopPropagation();
    };
  }

  function onPointerDown(e:React.PointerEvent){
    if(!ref.current) return;
    ref.current.setPointerCapture(e.pointerId);
    pts.current.set(e.pointerId, {x:e.clientX, y:e.clientY});
    // two fingers => pinch
    if (pts.current.size===2){
      const a=[...pts.current.values()];
      const d0=Math.hypot(a[0].x-a[1].x, a[0].y-a[1].y);
      const cx=(a[0].x+a[1].x)/2;
      pinch.current = { d0, centerT: fromX(cx), startSpan: domain };
    } else {
      // primary pointer down on background => pan
      setDrag({ kind:"pan", x0:e.clientX, start:viewStart, end:viewEnd });
    }
  }

  function onPointerMove(e:React.PointerEvent){
    if(!ref.current) return;
    // update pointers for pinch
    if(pts.current.has(e.pointerId)) pts.current.set(e.pointerId, {x:e.clientX, y:e.clientY});

    // pinch zoom
    if(pinch.current && pts.current.size===2){
      const a=[...pts.current.values()];
      const d1=Math.hypot(a[0].x-a[1].x, a[0].y-a[1].y);
      if(d1>0){
        const k = clamp(pinch.current.d0 / d1, 0.2, 4);
        let span = clamp(pinch.current.startSpan * k, 1_000, 12*60*60*1000);
        const c = pinch.current.centerT;
        setView(c - span/2, c + span/2);
      }
      return;
    }

    const dx = e.clientX - ("x0" in drag ? (drag as any).x0 : 0);
    const dt = (dx / widthPx()) * domain;

    switch(drag.kind){
      case "pan": {
        if (Math.abs(dx) < 1) return;
        setView(drag.start - dt, drag.end - dt);
        break;
      }
      case "reso": {
        const t = clamp(drag.t + dt, viewStart, viewEnd);
        setReso(t);
        break;
      }
      case "move":
      case "resize-l":
      case "resize-r": {
        // commit drag after threshold so clicks are easy
        if (!drag.committed && Math.abs(dx) < DRAG_THRESH) return;
        if (!drag.committed) setDrag({ ...drag, committed: true } as DragState);

        setShards(shards.map(s=>{
          if(s.id!==drag.id) return s;
          if(drag.kind==="move")   return ({...s, t0: drag.t0 + dt, t1: drag.t1 + dt});
          if(drag.kind==="resize-l") return ({...s, t0: Math.min(drag.t1-250, drag.t0 + dt)});
          return ({...s, t1: Math.max(drag.t0+250, drag.t1 + dt)});
        }));
        break;
      }
      default: break;
    }
  }

  function onPointerUp(e:React.PointerEvent){
    if(!ref.current) return;
    try{ ref.current.releasePointerCapture(e.pointerId); }catch{}
    pts.current.delete(e.pointerId);
    if(pts.current.size<2) pinch.current=null;
    // Click (no commit) selects shard if pointerup target holds data-id
    if(drag.kind==="move" || drag.kind==="resize-l" || drag.kind==="resize-r"){
      const d = drag as any;
      if(!d.committed){
        const id = (e.target as HTMLElement).closest("[data-shard-id]")?.getAttribute("data-shard-id");
        const sel = shards.find(s=>s.id===id) || null;
        if(sel){ setSelected(sel); pushLog(\`focus \${sel.label}\`); }
      }
    }
    setDrag({kind:"none"});
  }

  // Wheel: horizontal pan; zoom with ctrl/cmd
  function onWheel(e:React.WheelEvent){
    e.preventDefault();
    const delta = e.deltaY || e.deltaX;
    if (e.ctrlKey || e.metaKey) {
      // zoom around mouse x
      const cx = e.clientX - (ref.current?.getBoundingClientRect().left || 0);
      const centerT = fromX(cx);
      const k = clamp(1 + (delta > 0 ? 0.12 : -0.12), 0.2, 4);
      const span = clamp(domain * k, 1_000, 12*60*60*1000);
      setView(centerT - span/2, centerT + span/2);
    } else {
      // pan horizontally
      const dt = (delta / widthPx()) * domain;
      setView(viewStart + dt, viewEnd + dt);
    }
  }

  // convenience for reso drag start
  function onResoStart(e:React.PointerEvent){
    if(!ref.current) return;
    ref.current.setPointerCapture(e.pointerId);
    setDrag({ kind:"reso", x0:e.clientX, t:reso });
    e.stopPropagation();
  }

  // render
  return (
    <div
      ref={ref}
      className="timeline h-72 rounded-2xl border border-ink-800 card overflow-hidden select-none touch-none relative z-10"
      onPointerDown={onPointerDown}
      onPointerMove={onPointerMove}
      onPointerUp={onPointerUp}
      onPointerCancel={onPointerUp}
      onWheel={onWheel}
    >
      {/* grid rows */}
      <div className="absolute inset-0" style={{ backgroundImage:"linear-gradient(to bottom, rgba(255,255,255,.06) 1px, transparent 1px)", backgroundSize:"100% 32px" }} />

      {/* ticks */}
      {ticks.arr.map((t,i)=>(
        <div key={i} className="absolute top-0 bottom-0 border-l border-ink-800" style={{ left: `${toX(t)}px` }}>
          <div className="tick-label absolute top-0 -translate-x-1/2 text-[10px] text-ink-300 px-1">{new Date(t).toLocaleTimeString()}</div>
        </div>
      ))}

      {/* shards (pixel positioning for reliable hit areas) */}
      <div className="absolute top-10 left-0 right-0">
        {shards.slice(0,1000).map((s,idx)=>{
          const left = toX(s.t0);
          const width = Math.max(14, toX(s.t1) - toX(s.t0)); // min 14px for easy clicking
          const top = (idx % 6) * 32;

          return (
            <div
              key={s.id}
              data-shard-id={s.id}
              className="absolute"
              style={{ left: `${left}px`, width: `${width}px`, top }}
            >
              <div
                className="shard h-6 rounded-md shadow ring-1 ring-black/10 cursor-grab active:cursor-grabbing relative"
                style={{ background: s.color || "#8b5cf6" }}
                onPointerDown={makeShardStart("move", s)}
                title={s.label}
              >
                <div className="px-2 text-[11px] truncate text-black/85 font-medium select-none">{s.label}</div>
                <div className="handle l absolute left-0 top-0 bottom-0 w-2 cursor-ew-resize" onPointerDown={makeShardStart("resize-l", s)} />
                <div className="handle r absolute right-0 top-0 bottom-0 w-2 cursor-ew-resize" onPointerDown={makeShardStart("resize-r", s)} />
              </div>
            </div>
          );
        })}
      </div>

      {/* reso bar */}
      <div
        className="absolute top-0 bottom-0 w-[3px] bg-[#22c55e] shadow-[0_0_16px_#22c55e88] cursor-ew-resize"
        style={{ left:`${toX(reso)}px` }}
        onPointerDown={onResoStart}
      />

      {/* mini scrollbar background */}
      <div className="absolute bottom-0 left-0 right-0 h-3 bg-ink-900/70">
        <div className="h-full bg-ink-700/60 rounded-full" style={{
          width: `${Math.min(100, Math.max(12, (600000/domain)*100))}%`,
        }}/>
      </div>
    </div>
  );
}
