#!/usr/bin/env python
import argparse, json, os, re, shutil, sys, tempfile, zipfile
from pathlib import Path
def p(*a): print("[forge]", *a)
def extract_if_zip(src:str, tmp:Path)->Path:
    srcp = Path(src)
    if srcp.is_dir(): return srcp
    if srcp.is_file() and srcp.suffix.lower()==".zip":
        out = tmp / "payload"; out.mkdir(parents=True, exist_ok=True)
        with zipfile.ZipFile(srcp, 'r') as z: z.extractall(out)
        return out
    raise SystemExit(f"source not found: {src}")
def ensure(d:Path): d.mkdir(parents=True, exist_ok=True); return d
def copytree(src:Path, dst:Path, exts=None):
    exts = exts or []; ensure(dst); n=0
    for root, _, files in os.walk(src):
        r = Path(root)
        for f in files:
            if exts and Path(f).suffix.lower() not in exts: continue
            s = r/f; rel = s.relative_to(src); d = dst/rel
            ensure(d.parent); shutil.copy2(s, d); n+=1
    return n
def write_index_ts(target_dir:Path, header="// auto-generated by forge\n"):
    files=[]
    for root,_,fs in os.walk(target_dir):
        for f in fs:
            if f.endswith((".ts",".tsx")) and not f.startswith("index."):
                pth = Path(root)/f; rel = pth.relative_to(target_dir)
                mod = str(rel.with_suffix("")).replace("\\","/")
                files.append(mod)
    files.sort(); idx = target_dir/"index.ts"
    with open(idx, "w", encoding="utf-8") as w:
        w.write(header); [w.write(f"export * from './{m}';\n") for m in files]
    return idx
def sanitize_json_file(fp:Path)->bool:
    try:
        txt = fp.read_text("utf-8", errors="ignore")
        try: json.loads(txt); return True
        except Exception: pass
        cleaned=[]
        for line in txt.splitlines():
            L=line.strip()
            if not L: continue
            if re.match(r'^(begin file|end file)$', L, flags=re.I): continue
            if L in ("{","}","[","]"): cleaned.append(L); continue
            cleaned.append(line)
        new="\n".join(cleaned); json.loads(new); fp.write_text(new, "utf-8"); return True
    except Exception: return False
def main():
    ap = argparse.ArgumentParser(description="oriel forge (Pack A)")
    ap.add_argument("--project", required=True); ap.add_argument("--source", required=True)
    ap.add_argument("--force", action="store_true"); ap.add_argument("--import-user-shards", action="store_true")
    args = ap.parse_args()
    proj = Path(args.project).resolve()
    if not (proj/'package.json').exists(): raise SystemExit(f"not an oriel project: {proj}")
    # Pack A destinations
    D_SCHEMAS = ensure(proj/'src/specs')
    D_TYPES   = ensure(proj/'src/profiles')
    D_SHARDS  = ensure(proj/'src/ledger')
    D_MODULES = ensure(proj/'src/bays')
    D_MODES   = ensure(proj/'src/stances')
    D_COMP    = ensure(proj/'src/fixtures/extra')
    D_SHADERS = ensure(proj/'src/shaders/flux')
    D_ASSETS  = ensure(proj/'src/assets/yard')
    with tempfile.TemporaryDirectory() as td:
        tmp = Path(td); root = extract_if_zip(args.source, tmp)
        candidates = {
            'schemas':['schemas','schema','types/schemas','src/schemas','src/types/schemas'],
            'types':['shard_types','src/shard_types','src/shards/types','shards/types'],
            'shards':['shards','src/shards/data','data/shards','story_shards'],
            'modules':['modules','src/modules','ui','src/ui'],
            'modes':['modes','src/modes'],
            'components':['components/extra','src/components','ui/components'],
            'shaders':['shaders','glsl','src/shaders','assets/shaders'],
            'assets':['assets','src/assets','public/assets']
        }
        found={}
        for key, paths in candidates.items():
            for rel in paths:
                pth = root/rel
                if pth.exists():
                    found[key]=pth; break
        stats={}
        if 'schemas' in found: stats['schemas']=copytree(found['schemas'], D_SCHEMAS, exts=['.json','.ts','.tsx'])
        if 'types'   in found: stats['types']=copytree(found['types'],   D_TYPES,   exts=['.ts','.tsx'])
        if 'modules' in found: stats['modules']=copytree(found['modules'], D_MODULES, exts=['.ts','.tsx'])
        if 'modes'   in found: stats['modes']=copytree(found['modes'],   D_MODES,   exts=['.ts','.tsx'])
        if 'components' in found: stats['components']=copytree(found['components'], D_COMP, exts=['.ts','.tsx'])
        if 'shaders' in found: stats['shaders']=copytree(found['shaders'], D_SHADERS, exts=['.glsl','.vert','.frag','.wgsl'])
        if 'assets'  in found: stats['assets']=copytree(found['assets'],  D_ASSETS)
        if args.import_user_shards and 'shards' in found:
            n=0
            for rootdir,_,fs in os.walk(found['shards']):
                for f in fs:
                    s = Path(rootdir)/f
                    if s.suffix.lower() in ('.json','.csv','.ndjson'):
                        d = D_SHARDS/s.relative_to(found['shards']); d.parent.mkdir(parents=True, exist_ok=True)
                        shutil.copy2(s, d); 
                        if d.suffix.lower()=='.json': sanitize_json_file(d)
                        n+=1
            stats['user_shards']=n
        idx1 = write_index_ts(D_TYPES); idx2 = write_index_ts(D_SCHEMAS)
        p('done.')
        for k,v in stats.items(): p(f"- copied {k}: {v} files")
        p('indices:', idx1, idx2)
if __name__=='__main__': main()
